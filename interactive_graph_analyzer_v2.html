<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ‘ãƒãƒ³ã‚³ã‚°ãƒ©ãƒ•åˆ†æãƒ„ãƒ¼ãƒ« - å®Œå…¨è‡ªå‹•æ¤œå‡ºç‰ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --red: #ff5c5c;
      --blue: #5c8dff;
      --green: #4cd964;
      --orange: #ffa500;
      --purple: #8a2be2;
      --bg: #f9f9f9;
      --fg: #333;
      --mode-selected: #007aff;
      --mode-unselected: #aaa;
      --btn-radius: 8px;
    }
    body {
      font-family: 'Helvetica Neue', 'Hiragino Sans', sans-serif;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 1em;
    }
    h1, h2 {
      text-align: center;
      margin-bottom: 1em;
    }
    /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«éƒ¨ */
    #controls {
      max-width: 800px;
      margin: auto;
      background: white;
      padding: 1em;
      border-radius: var(--btn-radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .file-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
      width: 100%;
      margin-bottom: 0.5em;
    }
    .file-wrapper input[type="file"] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
    }
    .file-label {
      display: block;
      width: 100%;
      padding: 0.8em;
      background: var(--mode-selected);
      color: white;
      text-align: center;
      border-radius: var(--btn-radius);
      font-weight: bold;
      cursor: pointer;
    }
    .delete-button {
      width: 100%;
      padding: 0.8em;
      background: var(--red);
      color: white;
      border: none;
      border-radius: var(--btn-radius);
      font-weight: bold;
      margin-top: 0.5em;
      display: none;
    }
    /* ãƒœã‚¿ãƒ³è¡Œ */
    #buttonRow {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    #buttonRow button {
      flex: 1;
      min-width: 100px;
      padding: 0.8em;
      font-size: 1em;
      border-radius: var(--btn-radius);
      color: white;
      border: none;
      cursor: pointer;
      background: var(--mode-unselected);
      transition: background-color 0.2s;
    }
    /* å„ãƒœã‚¿ãƒ³ã®èƒŒæ™¯è‰² */
    #btnAutoAll { background: linear-gradient(135deg, var(--orange), var(--purple)); }
    #btnMax { background: var(--red); }
    #btnMin { background: var(--blue); }
    #btnZero { background: var(--green); }
    #btnCurrent { background: var(--purple); }
    #btnAutoDetect { background: var(--orange); }
    
    /* å‡¦ç†ä¸­ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
    .processing {
      display: none;
      text-align: center;
      padding: 20px;
      color: var(--mode-selected);
      font-weight: bold;
    }
    .processing.active {
      display: block;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,.3);
      border-radius: 50%;
      border-top-color: var(--mode-selected);
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* ã‚­ãƒ£ãƒ³ãƒã‚¹éƒ¨åˆ† */
    #container {
      position: relative;
      max-width: 800px;
      margin: 1em auto;
      border-radius: var(--btn-radius);
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
      background: white;
    }
    canvas {
      width: 100%;
      display: block;
    }
    .line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: currentColor;
      touch-action: none;
      cursor: grab;
      z-index: 10;
      transition: opacity 0.2s;
    }
    .line:hover {
      opacity: 0.8;
    }
    /* ãƒ©ãƒ™ãƒ« */
    .line .label {
      position: absolute;
      right: 10px;
      top: -20px;
      font-size: 0.9em;
      background: rgba(255,255,255,0.9);
      padding: 2px 8px;
      border-radius: 4px;
      color: inherit;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #lineMax { color: var(--red); }
    #lineMin { color: var(--blue); }
    #lineZero { color: var(--green); }
    #lineCurrent { color: var(--purple); }
    /* çµæœè¡¨ç¤ºéƒ¨ */
    #results {
      max-width: 800px;
      margin: 2em auto;
      background: white;
      padding: 1.5em;
      border-radius: var(--btn-radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 1em;
    }
    .result-item {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 6px;
      text-align: center;
    }
    .result-label {
      font-size: 0.9em;
      color: #666;
      margin-bottom: 5px;
    }
    .result-value {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--mode-selected);
    }
    /* æ¤œå‡ºæƒ…å ± */
    #detectionInfo {
      max-width: 800px;
      margin: 2em auto;
      background: #e8f5e9;
      padding: 1em;
      border-radius: var(--btn-radius);
      border: 1px solid #4caf50;
      display: none;
    }
    .detection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .detection-method {
      background: white;
      padding: 10px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    .detection-method strong {
      color: #4caf50;
    }
    /* ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ */
    #scaleAdjust {
      max-width: 800px;
      margin: 1em auto;
      background: white;
      padding: 1em;
      border-radius: var(--btn-radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .scale-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .scale-input {
      width: 100px;
      padding: 0.5em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    /* è‡ªå‹•æ¤œå‡ºã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
    .auto-status {
      background: #f0f7ff;
      border: 1px solid #2196f3;
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
      font-size: 0.9em;
    }
    .auto-status.success {
      background: #e8f5e9;
      border-color: #4caf50;
    }
    .auto-status.error {
      background: #ffebee;
      border-color: #f44336;
    }
    /* ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º */
    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      opacity: 0.3;
    }
    /* èª¬æ˜æ–‡ */
    .info-box {
      max-width: 800px;
      margin: 2em auto;
      font-size: 14px;
      line-height: 1.7;
      color: #444;
      background: #fff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
    @media (max-width: 600px) {
      .result-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      #buttonRow button {
        min-width: 80px;
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body>

  <h1>ğŸ° ãƒ‘ãƒãƒ³ã‚³ã‚°ãƒ©ãƒ•åˆ†æãƒ„ãƒ¼ãƒ« - å®Œå…¨è‡ªå‹•æ¤œå‡ºç‰ˆ</h1>

  <div id="controls">
    <div class="file-wrapper">
      <label class="file-label" for="imageInput">ã‚°ãƒ©ãƒ•ç”»åƒã‚’é¸æŠ</label>
      <input type="file" id="imageInput" accept="image/*">
    </div>
    <button id="deleteButton" class="delete-button">ç”»åƒã‚’å‰Šé™¤</button>
    
    <div class="processing" id="processingIndicator">
      <div class="spinner"></div>
      <span>å‡¦ç†ä¸­...</span>
    </div>
    
    <div id="buttonRow">
      <button id="btnAutoAll" onclick="autoDetectAll()">ğŸš€ å®Œå…¨è‡ªå‹•æ¤œå‡º</button>
      <button id="btnAutoDetect" onclick="autoDetect()">ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³æ¤œå‡º</button>
      <button id="btnZero" onclick="showLine('zero')">ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³</button>
      <button id="btnMax" onclick="showLine('max')">æœ€å¤§å€¤</button>
      <button id="btnMin" onclick="showLine('min')">æœ€å°å€¤</button>
      <button id="btnCurrent" onclick="showLine('current')">ç¾åœ¨ä½ç½®</button>
    </div>
    
    <div class="auto-status" id="autoStatus" style="display:none;"></div>
  </div>

  <div id="scaleAdjust">
    <h3>ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š</h3>
    <div class="scale-controls">
      <label>1ãƒ”ã‚¯ã‚»ãƒ« = </label>
      <input type="number" class="scale-input" id="scaleInput" value="120" step="0.1">
      <span>ã®å€¤</span>
      <button onclick="updateScale()">æ›´æ–°</button>
      <button onclick="showGrid()">ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</button>
    </div>
  </div>

  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="gridOverlay" class="grid-overlay" style="display:none;"></div>
    <div id="lineZero" class="line" style="display:none"><div class="label">ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³</div></div>
    <div id="lineMax" class="line" style="display:none"><div class="label">æœ€å¤§å€¤</div></div>
    <div id="lineMin" class="line" style="display:none"><div class="label">æœ€å°å€¤</div></div>
    <div id="lineCurrent" class="line" style="display:none"><div class="label">ç¾åœ¨</div></div>
  </div>

  <div id="results">
    <h2>åˆ†æçµæœ</h2>
    <div class="result-grid">
      <div class="result-item">
        <div class="result-label">æœ€å¤§å€¤</div>
        <div class="result-value" id="resultMax">-</div>
      </div>
      <div class="result-item">
        <div class="result-label">æœ€å°å€¤</div>
        <div class="result-value" id="resultMin">-</div>
      </div>
      <div class="result-item">
        <div class="result-label">ç¾åœ¨å€¤</div>
        <div class="result-value" id="resultCurrent">-</div>
      </div>
      <div class="result-item">
        <div class="result-label">å¤‰å‹•å¹…</div>
        <div class="result-value" id="resultRange">-</div>
      </div>
    </div>
  </div>

  <div id="detectionInfo">
    <h3>ğŸ” è‡ªå‹•æ¤œå‡ºçµæœ</h3>
    <div class="detection-grid" id="detectionGrid">
      <!-- æ¤œå‡ºçµæœãŒå‹•çš„ã«æŒ¿å…¥ã•ã‚Œã‚‹ -->
    </div>
  </div>

  <div class="info-box">
    <strong>ã€ä½¿ã„æ–¹ã€‘</strong><br>
    1. ã€Œã‚°ãƒ©ãƒ•ç”»åƒã‚’é¸æŠã€ã‹ã‚‰ãƒ‘ãƒãƒ³ã‚³ã®ã‚°ãƒ©ãƒ•ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰<br>
    2. ã€ŒğŸš€ å®Œå…¨è‡ªå‹•æ¤œå‡ºã€ãƒœã‚¿ãƒ³ã§å…¨ã¦ã®å€¤ã‚’è‡ªå‹•æ¤œå‡ºï¼<br>
    3. å¿…è¦ã«å¿œã˜ã¦å„ãƒ©ã‚¤ãƒ³ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§å¾®èª¿æ•´<br>
    4. ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šã§1ãƒ”ã‚¯ã‚»ãƒ«ã‚ãŸã‚Šã®å€¤ã‚’èª¿æ•´ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 120ï¼‰<br>
    5. åˆ†æçµæœãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¡¨ç¤ºã•ã‚Œã‚‹<br><br>
    
    <strong>ã€å®Œå…¨è‡ªå‹•æ¤œå‡ºã«ã¤ã„ã¦ã€‘</strong><br>
    ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ä»¥ä¸‹ã‚’è‡ªå‹•ã§æ¤œå‡ºã—ã¾ã™ï¼š<br>
    âœ… ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³ï¼ˆYâ‰ˆ250ï¼‰<br>
    âœ… æœ€å¤§å€¤ï¼ˆã‚°ãƒ©ãƒ•ã®æœ€é«˜ç‚¹ï¼‰<br>
    âœ… æœ€å°å€¤ï¼ˆã‚°ãƒ©ãƒ•ã®æœ€ä½ç‚¹ï¼‰<br>
    âœ… ç¾åœ¨ä½ç½®ï¼ˆã‚°ãƒ©ãƒ•ã®çµ‚ç‚¹ï¼‰<br><br>
    
    é«˜ç²¾åº¦ãªç”»åƒå‡¦ç†ã«ã‚ˆã‚Šã€æ‰‹å‹•èª¿æ•´ãªã—ã§å³åº§ã«åˆ†æå¯èƒ½ï¼
  </div>

  <script>
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const deleteButton = document.getElementById('deleteButton');
    const container = document.getElementById('container');
    const scaleInput = document.getElementById('scaleInput');
    const processingIndicator = document.getElementById('processingIndicator');
    const autoStatus = document.getElementById('autoStatus');
    
    const lines = {
      zero: document.getElementById('lineZero'),
      max: document.getElementById('lineMax'),
      min: document.getElementById('lineMin'),
      current: document.getElementById('lineCurrent')
    };
    
    let img = new Image();
    let dragging = null;
    let scale = 120; // 1ãƒ”ã‚¯ã‚»ãƒ«ã‚ãŸã‚Šã®å€¤
    let imageLoaded = false;
    let autoDetectionResult = null;

    // ç”»åƒå‡¦ç†
    function handleImage(file) {
      if (!file) return;
      
      showProcessing(true);
      
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        // åˆæœŸåŒ–
        Object.values(lines).forEach(line => {
          line.style.display = "none";
        });
        
        imageLoaded = true;
        deleteButton.style.display = "block";
        document.getElementById('detectionInfo').style.display = "none";
        autoStatus.style.display = "none";
        
        // è‡ªå‹•ã§å®Œå…¨æ¤œå‡ºã‚’å®Ÿè¡Œ
        setTimeout(() => autoDetectAll(), 100);
      };
      
      img.src = URL.createObjectURL(file);
    }
    
    imageInput.addEventListener('change', e => handleImage(e.target.files[0]));
    
    // å‡¦ç†ä¸­è¡¨ç¤º
    function showProcessing(show) {
      if (show) {
        processingIndicator.classList.add('active');
      } else {
        processingIndicator.classList.remove('active');
      }
    }
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
    function showStatus(message, type = 'info') {
      autoStatus.className = 'auto-status ' + type;
      autoStatus.textContent = message;
      autoStatus.style.display = 'block';
    }
    
    // ç”»åƒå‰Šé™¤
    deleteButton.addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      Object.values(lines).forEach(line => {
        line.style.display = "none";
      });
      imageLoaded = false;
      deleteButton.style.display = "none";
      document.getElementById('detectionInfo').style.display = "none";
      autoStatus.style.display = "none";
      updateResults();
    });

    // å®Œå…¨è‡ªå‹•æ¤œå‡º
    async function autoDetectAll() {
      if (!imageLoaded) {
        alert('å…ˆã«ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„');
        return;
      }
      
      showProcessing(true);
      showStatus('è‡ªå‹•æ¤œå‡ºã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...', 'info');
      
      try {
        // 1. ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³æ¤œå‡º
        await autoDetect();
        
        // 2. ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
        const graphData = await extractGraphData();
        
        if (graphData) {
          const canvasRect = canvas.getBoundingClientRect();
          const canvasScale = canvas.height / canvasRect.height;
          
          // 3. æœ€å¤§å€¤è¨­å®š
          if (graphData.maxY !== null) {
            const maxDisplayY = graphData.maxY / canvasScale;
            lines.max.style.top = `${maxDisplayY}px`;
            lines.max.style.display = "block";
          }
          
          // 4. æœ€å°å€¤è¨­å®š
          if (graphData.minY !== null) {
            const minDisplayY = graphData.minY / canvasScale;
            lines.min.style.top = `${minDisplayY}px`;
            lines.min.style.display = "block";
          }
          
          // 5. ç¾åœ¨ä½ç½®è¨­å®š
          if (graphData.currentY !== null) {
            const currentDisplayY = graphData.currentY / canvasScale;
            lines.current.style.top = `${currentDisplayY}px`;
            lines.current.style.display = "block";
          }
          
          updateResults();
          showStatus('âœ… å®Œå…¨è‡ªå‹•æ¤œå‡ºãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
        }
      } catch (error) {
        showStatus('âŒ è‡ªå‹•æ¤œå‡ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
        console.error(error);
      } finally {
        showProcessing(false);
      }
    }
    
    // ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
    async function extractGraphData() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { width, height, data } = imageData;
      
      // ã‚°ãƒ©ãƒ•ã®è‰²ã‚’æ¤œå‡ºï¼ˆãƒ”ãƒ³ã‚¯ã€ã‚ªãƒ¬ãƒ³ã‚¸ã€èµ¤ãªã©ï¼‰
      const graphPoints = [];
      
      for (let x = 0; x < width; x++) {
        let graphY = null;
        
        // å„åˆ—ã§æœ€ã‚‚ã‚°ãƒ©ãƒ•ã‚‰ã—ã„ç‚¹ã‚’æ¢ã™
        for (let y = 0; y < height; y++) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          // HSVå¤‰æ›
          const hsv = rgbToHsv(r, g, b);
          
          // ã‚°ãƒ©ãƒ•ã®è‰²åˆ¤å®šï¼ˆãƒ”ãƒ³ã‚¯ã€ã‚ªãƒ¬ãƒ³ã‚¸ã€èµ¤ç³»ï¼‰
          if (isGraphColor(hsv)) {
            graphY = y;
            break; // æœ€åˆã«è¦‹ã¤ã‹ã£ãŸç‚¹ã‚’æ¡ç”¨
          }
        }
        
        if (graphY !== null) {
          graphPoints.push({ x, y: graphY });
        }
      }
      
      if (graphPoints.length < 10) {
        console.warn('ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã™ãã¾ã™');
        return null;
      }
      
      // æœ€å¤§å€¤ã€æœ€å°å€¤ã€ç¾åœ¨å€¤ã‚’è¨ˆç®—
      let maxY = graphPoints[0].y;
      let minY = graphPoints[0].y;
      let currentY = null;
      
      graphPoints.forEach(point => {
        if (point.y < maxY) maxY = point.y; // Yåº§æ¨™ã¯ä¸ŠãŒå°ã•ã„
        if (point.y > minY) minY = point.y;
      });
      
      // ç¾åœ¨å€¤ã¯å³ç«¯ã®ã‚°ãƒ©ãƒ•ç‚¹
      const rightPoints = graphPoints.filter(p => p.x > width * 0.9);
      if (rightPoints.length > 0) {
        currentY = rightPoints[rightPoints.length - 1].y;
      }
      
      return { maxY, minY, currentY, points: graphPoints };
    }
    
    // RGB to HSVå¤‰æ›
    function rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
      
      let h = 0;
      let s = max === 0 ? 0 : diff / max;
      let v = max;
      
      if (diff !== 0) {
        switch (max) {
          case r:
            h = ((g - b) / diff + (g < b ? 6 : 0)) / 6;
            break;
          case g:
            h = ((b - r) / diff + 2) / 6;
            break;
          case b:
            h = ((r - g) / diff + 4) / 6;
            break;
        }
      }
      
      return { h: h * 360, s: s * 100, v: v * 100 };
    }
    
    // ã‚°ãƒ©ãƒ•ã®è‰²åˆ¤å®š
    function isGraphColor(hsv) {
      // ãƒ”ãƒ³ã‚¯ç³» (300-360, 0-30)
      if ((hsv.h >= 300 || hsv.h <= 30) && hsv.s > 30 && hsv.v > 50) {
        return true;
      }
      // ã‚ªãƒ¬ãƒ³ã‚¸ç³» (10-40)
      if (hsv.h >= 10 && hsv.h <= 40 && hsv.s > 50 && hsv.v > 50) {
        return true;
      }
      // èµ¤ç³» (0-10, 350-360)
      if ((hsv.h <= 10 || hsv.h >= 350) && hsv.s > 50 && hsv.v > 40) {
        return true;
      }
      return false;
    }

    // ãƒ©ã‚¤ãƒ³è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    function showLine(type) {
      if (!imageLoaded) {
        alert('å…ˆã«ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„');
        return;
      }
      
      const line = lines[type];
      const canvasRect = canvas.getBoundingClientRect();
      
      if (line.style.display !== "block") {
        // åˆæœŸä½ç½®è¨­å®š
        let initialY = canvasRect.height / 2;
        
        if (type === 'zero' && autoDetectionResult) {
          // è‡ªå‹•æ¤œå‡ºçµæœãŒã‚ã‚‹å ´åˆã¯ä½¿ç”¨
          initialY = autoDetectionResult.y / (canvas.height / canvasRect.height);
        } else if (type === 'max') {
          initialY = canvasRect.height * 0.2;
        } else if (type === 'min') {
          initialY = canvasRect.height * 0.8;
        }
        
        line.style.top = `${initialY}px`;
        line.style.display = "block";
      }
      
      updateResults();
    }

    // è‡ªå‹•æ¤œå‡ºï¼ˆã‚¼ãƒ­ãƒ©ã‚¤ãƒ³ã®ã¿ï¼‰
    async function autoDetect() {
      if (!imageLoaded) {
        alert('å…ˆã«ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„');
        return;
      }
      
      // Canvas ã‹ã‚‰ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // è¤‡æ•°ã®æ¤œå‡ºæ‰‹æ³•ã‚’å®Ÿè¡Œ
      const results = {
        thickGrayLine: detectThickGrayLine(imageData),
        horizontalLines: detectHorizontalLines(imageData),
        edgeBased: detectEdgeBased(imageData),
        intensityGradient: detectIntensityGradient(imageData)
      };
      
      // çµæœã‚’çµ±åˆ
      const validResults = Object.entries(results)
        .filter(([_, r]) => r && r.y !== null)
        .map(([method, r]) => ({ method, ...r }));
      
      if (validResults.length > 0) {
        // ä¿¡é ¼åº¦ã§é‡ã¿ä»˜ã‘å¹³å‡
        const weightedSum = validResults.reduce((sum, r) => sum + r.y * r.confidence, 0);
        const totalConfidence = validResults.reduce((sum, r) => sum + r.confidence, 0);
        const finalY = Math.round(weightedSum / totalConfidence);
        
        autoDetectionResult = {
          y: finalY,
          confidence: totalConfidence / validResults.length,
          methods: results
        };
        
        // ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º
        const canvasRect = canvas.getBoundingClientRect();
        const displayY = finalY / (canvas.height / canvasRect.height);
        lines.zero.style.top = `${displayY}px`;
        lines.zero.style.display = "block";
        
        // æ¤œå‡ºæƒ…å ±ã‚’è¡¨ç¤º
        showDetectionInfo(results);
        updateResults();
      } else {
        alert('è‡ªå‹•æ¤œå‡ºã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚');
      }
    }

    // æ¤œå‡ºæ‰‹æ³•1: å¤ªã„ã‚°ãƒ¬ãƒ¼ã®ç·šã‚’æ¤œå‡º
    function detectThickGrayLine(imageData) {
      const { width, height, data } = imageData;
      const centerY = Math.floor(height / 2);
      const searchRange = 100;
      
      let bestY = null;
      let bestScore = 0;
      
      for (let y = centerY - searchRange; y < centerY + searchRange; y++) {
        if (y < 0 || y >= height) continue;
        
        let grayCount = 0;
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          // ã‚°ãƒ¬ãƒ¼åˆ¤å®š
          if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && r > 60 && r < 120) {
            grayCount++;
          }
        }
        
        const score = grayCount / width;
        if (score > bestScore && score > 0.8) {
          bestScore = score;
          bestY = y;
        }
      }
      
      return bestY !== null ? { y: bestY, confidence: bestScore } : null;
    }

    // æ¤œå‡ºæ‰‹æ³•2: æ°´å¹³ç·šæ¤œå‡º
    function detectHorizontalLines(imageData) {
      const { width, height } = imageData;
      const edges = detectEdges(imageData);
      
      const centerY = Math.floor(height / 2);
      const searchRange = 100;
      
      let bestY = null;
      let bestScore = 0;
      
      for (let y = centerY - searchRange; y < centerY + searchRange; y++) {
        if (y < 0 || y >= height) continue;
        
        let edgeCount = 0;
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (edges[idx] > 128) {
            edgeCount++;
          }
        }
        
        const score = edgeCount / width;
        if (score > bestScore && score > 0.6) {
          bestScore = score;
          bestY = y;
        }
      }
      
      return bestY !== null ? { y: bestY, confidence: bestScore * 0.7 } : null;
    }

    // æ¤œå‡ºæ‰‹æ³•3: ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹æ¤œå‡º
    function detectEdgeBased(imageData) {
      const { height } = imageData;
      const edges = detectEdges(imageData);
      const profile = computeHorizontalProfile(edges, imageData.width);
      
      const centerY = Math.floor(height / 2);
      const searchRange = 100;
      
      let maxVal = 0;
      let maxY = centerY;
      
      for (let y = centerY - searchRange; y < centerY + searchRange; y++) {
        if (y < 0 || y >= height) continue;
        if (profile[y] > maxVal) {
          maxVal = profile[y];
          maxY = y;
        }
      }
      
      const confidence = Math.min(maxVal / 255, 1) * 0.6;
      return { y: maxY, confidence };
    }

    // æ¤œå‡ºæ‰‹æ³•4: è¼åº¦å‹¾é…
    function detectIntensityGradient(imageData) {
      const { width, height, data } = imageData;
      const profile = new Array(height).fill(0);
      
      // å‚ç›´æ–¹å‘ã®å¹³å‡è¼åº¦
      for (let y = 0; y < height; y++) {
        let sum = 0;
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          sum += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        }
        profile[y] = sum / width;
      }
      
      // å‹¾é…è¨ˆç®—
      const gradient = new Array(height - 1);
      for (let y = 0; y < height - 1; y++) {
        gradient[y] = Math.abs(profile[y + 1] - profile[y]);
      }
      
      const centerY = Math.floor(height / 2);
      const searchRange = 100;
      
      let maxGrad = 0;
      let maxY = centerY;
      
      for (let y = centerY - searchRange; y < centerY + searchRange; y++) {
        if (y < 0 || y >= gradient.length) continue;
        if (gradient[y] > maxGrad) {
          maxGrad = gradient[y];
          maxY = y;
        }
      }
      
      const confidence = Math.min(maxGrad / 50, 1) * 0.5;
      return { y: maxY, confidence };
    }

    // ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆç°¡æ˜“Sobelï¼‰
    function detectEdges(imageData) {
      const { width, height, data } = imageData;
      const edges = new Uint8Array(width * height);
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          
          // å‚ç›´æ–¹å‘ã®Sobel
          const idx_top = ((y - 1) * width + x) * 4;
          const idx_bottom = ((y + 1) * width + x) * 4;
          const gray_top = (data[idx_top] + data[idx_top + 1] + data[idx_top + 2]) / 3;
          const gray_bottom = (data[idx_bottom] + data[idx_bottom + 1] + data[idx_bottom + 2]) / 3;
          
          const edge = Math.abs(gray_bottom - gray_top);
          edges[y * width + x] = Math.min(edge * 2, 255);
        }
      }
      
      return edges;
    }

    // æ°´å¹³ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨ˆç®—
    function computeHorizontalProfile(edges, width) {
      const height = edges.length / width;
      const profile = new Array(height).fill(0);
      
      for (let y = 0; y < height; y++) {
        let sum = 0;
        for (let x = 0; x < width; x++) {
          sum += edges[y * width + x];
        }
        profile[y] = sum / width;
      }
      
      return profile;
    }

    // æ¤œå‡ºæƒ…å ±è¡¨ç¤º
    function showDetectionInfo(results) {
      const infoDiv = document.getElementById('detectionInfo');
      const gridDiv = document.getElementById('detectionGrid');
      
      gridDiv.innerHTML = '';
      
      const methodNames = {
        thickGrayLine: 'å¤ªã„ã‚°ãƒ¬ãƒ¼ç·šæ¤œå‡º',
        horizontalLines: 'æ°´å¹³ç·šæ¤œå‡º',
        edgeBased: 'ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹æ¤œå‡º',
        intensityGradient: 'è¼åº¦å‹¾é…åˆ†æ'
      };
      
      Object.entries(results).forEach(([method, result]) => {
        if (result && result.y !== null) {
          const div = document.createElement('div');
          div.className = 'detection-method';
          div.innerHTML = `
            <strong>${methodNames[method]}</strong><br>
            Yåº§æ¨™: ${result.y}<br>
            ä¿¡é ¼åº¦: ${(result.confidence * 100).toFixed(1)}%
          `;
          gridDiv.appendChild(div);
        }
      });
      
      infoDiv.style.display = 'block';
    }

    // ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œ
    function getEventY(e) {
      const rect = container.getBoundingClientRect();
      return (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    }

    function startDrag(e, lineKey) {
      dragging = lineKey;
      e.preventDefault();
    }

    function drag(e) {
      if (!dragging) return;
      e.preventDefault();
      
      const y = getEventY(e);
      const containerHeight = canvas.getBoundingClientRect().height;
      const newY = Math.max(0, Math.min(y, containerHeight));
      lines[dragging].style.top = `${newY}px`;
      updateResults();
    }

    function endDrag() {
      dragging = null;
    }

    // ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
    Object.entries(lines).forEach(([key, line]) => {
      line.addEventListener('mousedown', e => startDrag(e, key));
      line.addEventListener('touchstart', e => startDrag(e, key), { passive: false });
    });
    
    window.addEventListener('mousemove', drag);
    window.addEventListener('touchmove', drag, { passive: false });
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);

    // ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°
    function updateScale() {
      scale = parseFloat(scaleInput.value) || 120;
      updateResults();
    }

    // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
    function showGrid() {
      const gridOverlay = document.getElementById('gridOverlay');
      if (gridOverlay.style.display === 'none') {
        drawGrid();
        gridOverlay.style.display = 'block';
      } else {
        gridOverlay.style.display = 'none';
      }
    }

    function drawGrid() {
      const gridOverlay = document.getElementById('gridOverlay');
      gridOverlay.innerHTML = '';
      
      if (!lines.zero.style.display || lines.zero.style.display === 'none') return;
      
      const rect = canvas.getBoundingClientRect();
      const canvasScale = canvas.height / rect.height;
      const zeroY = parseFloat(lines.zero.style.top);
      
      // 10000å˜ä½ã®ã‚°ãƒªãƒƒãƒ‰ç·š
      const gridInterval = 10000 / scale; // ãƒ”ã‚¯ã‚»ãƒ«å˜ä½
      
      for (let i = -10; i <= 10; i++) {
        if (i === 0) continue;
        
        const y = zeroY - (i * gridInterval / canvasScale);
        if (y < 0 || y > rect.height) continue;
        
        const gridLine = document.createElement('div');
        gridLine.style.position = 'absolute';
        gridLine.style.top = `${y}px`;
        gridLine.style.left = '0';
        gridLine.style.right = '0';
        gridLine.style.height = '1px';
        gridLine.style.background = i % 3 === 0 ? '#666' : '#ccc';
        
        const label = document.createElement('div');
        label.style.position = 'absolute';
        label.style.right = '5px';
        label.style.top = '-10px';
        label.style.fontSize = '12px';
        label.style.color = '#666';
        label.textContent = `${i * 10000}`;
        
        gridLine.appendChild(label);
        gridOverlay.appendChild(gridLine);
      }
    }

    // çµæœæ›´æ–°
    function updateResults() {
      const rect = canvas.getBoundingClientRect();
      const canvasScale = canvas.height / rect.height;
      
      const getY = id => {
        if (lines[id].style.display === "block") {
          return parseFloat(lines[id].style.top) * canvasScale;
        }
        return null;
      };
      
      const zeroY = getY('zero');
      const maxY = getY('max');
      const minY = getY('min');
      const currentY = getY('current');
      
      let maxValue = '-';
      let minValue = '-';
      let currentValue = '-';
      let rangeValue = '-';
      
      if (zeroY !== null) {
        if (maxY !== null) {
          maxValue = Math.round((zeroY - maxY) * scale);
          lines.max.querySelector('.label').textContent = `æœ€å¤§å€¤ (+${maxValue})`;
        }
        
        if (minY !== null) {
          minValue = Math.round((zeroY - minY) * scale);
          lines.min.querySelector('.label').textContent = `æœ€å°å€¤ (${minValue})`;
        }
        
        if (currentY !== null) {
          currentValue = Math.round((zeroY - currentY) * scale);
          const sign = currentValue >= 0 ? '+' : '';
          lines.current.querySelector('.label').textContent = `ç¾åœ¨ (${sign}${currentValue})`;
        }
        
        if (maxY !== null && minY !== null) {
          rangeValue = Math.abs(maxValue - minValue);
        }
      }
      
      document.getElementById('resultMax').textContent = maxValue !== '-' ? `+${maxValue}` : '-';
      document.getElementById('resultMin').textContent = minValue !== '-' ? `${minValue}` : '-';
      document.getElementById('resultCurrent').textContent = currentValue !== '-' ? 
        (currentValue >= 0 ? `+${currentValue}` : `${currentValue}`) : '-';
      document.getElementById('resultRange').textContent = rangeValue !== '-' ? rangeValue : '-';
    }
  </script>

</body>
</html>